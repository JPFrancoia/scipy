! Signatures for f2py wrappers of FORTRAN LAPACK functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
! $Revision$ $Date$
!
! Additions by Travis Oliphant, Tiziano Zito, Collin RM Stocks, Fabian Pedregosa
!              Skipper Seabold, Ilhan Polat
!
! Shorthand Notations:
! --------------------
! <prefix=s,d,c,z>
! <prefix2=s,d>
! <prefix2c=c,z>
! <ftype=real,double precision,complex,double complex>
! <ftype2=real,double precision>
! <ftype2c=complex,double complex>
! <ftypereal=real,double precision,real,double precision>
! <ftypecomplex=complex,double complex,\0,\1>
! <ctype=float,double,complex_float,complex_double>
! <ctype2=float,double>
! <ctype2c=complex_float,complex_double>
! <ctypereal=float,double,float,double>
! <ctypecomplex=complex_float,complex_double,\0,\1>
!

python module _flapack
interface

    ! Following classification is due to
    ! http://www.netlib.org/lapack/explore-html/

    include 'flapack_user.pyf.src'
    include 'flapack_gen.pyf.src'
    include 'flapack_gen_banded.pyf.src'
    include 'flapack_gen_tri.pyf.src'
    include 'flapack_sym_herm.pyf.src'
    include 'flapack_pos_def.pyf.src'
    include 'flapack_pos_def_tri.pyf.src'
    include 'flapack_other.pyf.src'


subroutine <prefix2>lasd4( n, i, d, z, delta, rho, sigma, work, info )
	! sigma, delta, work, info = lasd4(d,z,i,rho=1.0)
   	! Computes i-th square root of eigenvalue of rank one augmented diagonal matrix. Needed by SVD update procedure

	callstatement { i++; (*f2py_func)( &n, &i, d, z, delta, &rho, &sigma, work, &info); }
    callprotoargument int*, int*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, int*

	integer intent(hide),depend(d):: n = shape(d,0)
	integer intent(in),depend(d),check(i>=0 && i<=(shape(d,0)-1)):: i

	<ftype2> dimension(n),intent(in)           :: d
	<ftype2> dimension(n),intent(in),depend(n) :: z

	<ftype2> intent(out) :: sigma
	<ftype2> dimension(n),intent(out),depend(n) :: delta
	<ftype2> intent(in),optional:: rho = 1.0

	<ftype2> dimension(n),intent(out),depend(n) :: work
	integer intent(out) :: info

end subroutine <prefix2>lasd4

subroutine <prefix>lauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,<ctype>*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    <ftype> dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine <prefix>lauum

subroutine <prefix>laswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {int i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument int*,<ctype>*,int*,int*,int*,int*,int*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    <ftype> dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine <prefix>laswp

! dlamch = dlamch(cmach)
!
! determine double precision machine parameters
!  CMACH   (input) CHARACTER*1
!          Specifies the value to be returned by DLAMCH:
!          = 'E' or 'e',   DLAMCH := eps
!          = 'S' or 's ,   DLAMCH := sfmin
!          = 'B' or 'b',   DLAMCH := base
!          = 'P' or 'p',   DLAMCH := eps*base
!          = 'N' or 'n',   DLAMCH := t
!          = 'R' or 'r',   DLAMCH := rnd
!          = 'M' or 'm',   DLAMCH := emin
!          = 'U' or 'u',   DLAMCH := rmin
!          = 'L' or 'l',   DLAMCH := emax
!          = 'O' or 'o',   DLAMCH := rmax
!
!          where
!
!          eps   = relative machine precision
!          sfmin = safe minimum, such that 1/sfmin does not overflow
!          base  = base of the machine
!          prec  = eps*base
!          t     = number of (base) digits in the mantissa
!          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
!          emin  = minimum exponent before (gradual) underflow
!          rmin  = underflow threshold - base**(emin-1)
!          emax  = largest exponent before overflow
!          rmax  = overflow threshold  - (base**emax)*(1-eps)
function dlamch(cmach)
    character :: cmach
    double precision intent(out):: dlamch
end function dlamch

function slamch(cmach)
    character :: cmach
    real intent(out):: slamch
end function slamch

function <prefix2>lange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a real matrix A.
    <ftype2> <prefix2>lange, n2
    callstatement (*f2py_func)(&<prefix2>lange,norm,&m,&n,a,&lda,work)
    callprotoargument <ctype2>*,char*,int*,int*,<ctype2>*,int*,<ctype2>*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    <ftype2> dimension(m,n),intent(in) :: a
    <ftype2> dimension(m+1),intent(cache,hide) :: work
end function <prefix2>lange

function <prefix2c>lange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a complex matrix A.
    <ftype2> <prefix2c>lange, n2
    callstatement (*f2py_func)(&<prefix2c>lange,norm,&m,&n,a,&lda,work)
    callprotoargument <ctype2>*,char*,int*,int*,<ctype2c>*,int*,<ctype2>*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    <ftype2c> dimension(m,n),intent(in) :: a
    <ftype2> dimension(m+1),intent(cache,hide) :: work
end function <prefix2c>lange

subroutine <prefix>larfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    <ftype> intent(in,out) :: alpha
    <ftype> intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    <ftype> intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine <prefix>larfg

subroutine <prefix>larf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    <ftype> intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    <ftype> intent(in) :: tau
    <ftype> dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    <ftype> intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine <prefix>larf

subroutine <prefix>lartg(f,g,cs,sn,r)
    <ftype> intent(in) :: f
    <ftype> intent(in) :: g
    <real,double precision,\0,\1> intent(out) :: cs
    <ftype> intent(out) :: sn
    <ftype> intent(out) :: r
end subroutine <prefix>lartg

subroutine <prefix2c>rot(n,x,offx,incx,y,offy,incy,c,s,lx,ly)
    callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
    callprotoargument int*,<ctype2c>*,int*,<ctype2c>*,int*,<float,double>*,<ctype2c>*
    <ftype2c> dimension(lx),intent(in,out,copy) :: x
    <ftype2c> dimension(ly),intent(in,out,copy) :: y
    integer intent(hide),depend(x) :: lx = len(x)
    integer intent(hide),depend(y) :: ly = len(y)
    <real,double precision> intent(in) :: c
    <ftype2c> intent(in) :: s
    integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
    integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
    integer optional, intent(in), depend(lx), check(offx>=0 && offx<lx) :: offx=0
    integer optional, intent(in), depend(ly), check(offy>=0 && offy<ly) :: offy=0
    integer optional, intent(in), depend(lx,incx,offx,ly,incy,offy) :: n = (lx-1-offx)/abs(incx)+1
    check(lx-offx>(n-1)*abs(incx)) :: n
    check(ly-offy>(n-1)*abs(incy)) :: n
end subroutine <prefix2c>rot

subroutine ilaver(major, minor, patch)
    integer intent(out) :: major
    integer intent(out) :: minor
    integer intent(out) :: patch
end subroutine ilaver

end interface

end python module _flapack

! This file was auto-generated with f2py (version:2.10.173).
! See http://cens.ioc.ee/projects/f2py2e/
